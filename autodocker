#!/usr/bin/env node-dev
process.env.DEBUG   = process.env.DEBUG || "*,-portastic*"
require('./init').init()

const R             = require('ramda')
const debug         = R.memoize(require('debug'))
const fs            = require('fs')
const {spawn, exec} = require('./process')
const config        = require(configPath)
const proxyRules    = require('./proxyRules')
const git           = require('./git')
const docker        = require('./docker')

const buildBranches = ({cwd, refs, name}) => {
  git.updateBranches(cwd)
  
  sequence = Promise.resolve()
  R.map(ref => {
    let {branch, commit, message, image} = git.parseRef(ref, name)
    let port = null
    sequence = sequence
    .then( () => {
      let running = docker.getRunning(image)
      if (R.contains(ref, git.getLocalBranchesHEAD(cwd)) && running) {
        proxyRules.add(image, running.ports[0])
        debug(`branch ${branch}`)('up to date and running')
        return Promise.resolve()
      }
        
      debug("branch")(branch, commit, message)
      
      git.checkout({branch, cwd})
      git.pull(cwd)
      return Promise.resolve()
        .then(() => spawn(`docker build --tag ${image} ${cwd}`))
        .then(() => docker.getImageRunPortsOrFreePorts(image))
        .then(ports => port = R.head(ports))
        .then(() => docker.removeIfRunning(image))
        .then(() => proxyRules.add(image, port))
        .then(() => docker.runImageOnPort(image, cwd, port))
        .catch(debug('autodocker:error'))
    })
  }, refs)
  
  return sequence
}

const processRepo = (path) => {
  const name = R.takeLast(2, path.replace('.git','').split('/')).join('/')
  const cwd = [config.workdir,name].join('/')
  git.cloneIfNotExists({path, cwd})
  return buildBranches({cwd, name, refs: git.getRemoteBranchesHEAD(cwd)})
  .then(proxyRules.write)
}

const start = () => {
  return Promise.all(
    R.map(processRepo, config.repositories)
  )
  .then(start)
  .catch(debug('autodoker:error'))
}
start()
