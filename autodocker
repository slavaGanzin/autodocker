#!/usr/bin/env node-dev
process.env.DEBUG   = process.env.DEBUG || "*,-portastic*"

const R             = require('ramda')
const debug         = R.memoize(require('debug'))
const fs            = require('fs')
const {spawn, exec} = require('./process')
const config        = require('./config')
const proxyRules    = require('./proxyRules')
const git           = require('./git')
const docker        = require('./docker')

const refreshDns = (image) =>
  exec(`(grep "${image}/127.0.0.1" /etc/dnsmasq.conf || echo "address=/${image}/127.0.0.1" >> /etc/dnsmasq.conf) && pkill dnsmasq; dnsmasq`)

const createDir = (dir) => {
  try {
    fs.statSync(dir)
  } catch (e) {
    exec(`mkdir ${dir}`)
  }
}

const buildBranches = ({cwd, refs, name}) => {
  git.updateBranches(cwd)
  
  sequence = Promise.resolve()
  R.map(ref => {
    let [,branch, commit, message] = R.match(/(\w+)\s+(\w+)\s+(.*)/, ref)
    let image = `${name}.${branch}`.toLowerCase().replace(/[\/]/g, '.').split('.').reverse().join('.')
    let port = null
    sequence = sequence
    .then( () => {
      let running = docker.getRunning(image)
      if (R.contains(ref, git.getLocalBranchesHEAD(cwd)) && running) {
        proxyRules.add(image, running.ports[0])
        debug(`branch ${branch}`)('up to date and running')
        return Promise.resolve()
      }
        
      debug("branch")(branch, commit, message)
      
      git.checkout({branch, cwd})
      git.pull(cwd)
      return Promise.resolve()
        .then(() => spawn(`docker build --tag ${image} ${cwd}`))
        .then(() => docker.getImageRunPortsOrFreePorts(image))
        .then(ports => port = R.head(ports))
        .then(() => docker.removeIfRunning(image))
        .then(() => proxyRules.add(image, port))
        .then(() => refreshDns(image))
        .then(() => docker.runImageOnPort(image, cwd, port))
        .catch(debug('autodocker:error'))
    })
  }, refs)
  
  return sequence
}

const processRepo = (path) => {
  const name = R.takeLast(2, path.replace('.git','').split('/')).join('/')
  const cwd = [config.workdir,name].join('/')
  git.cloneIfNotExists({path, cwd})
  return buildBranches({cwd, name, refs: git.getRemoteBranchesHEAD(cwd)})
  .then(proxyRules.write)
}

R.map(createDir, [config.logdir, config.workdir])
const start = () => {
  return Promise.all(
    R.map(processRepo, config.repositories)
  )
  .then(start)
  .catch(debug('autodoker:error'))
}
start()
